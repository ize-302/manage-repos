{"version":3,"sources":["../../src/responsive.ts"],"names":["breakpoints","Object","freeze","mapResponsive","prop","mapper","map","item","reduce","result","key","objectToArrayNotation","obj","bps","br","pop","arrayToObjectNotation","values","forEach","value","index","isResponsiveObjectLike","keys","length","every","includes","analyzeCSSValue","num","parseFloat","toString","unit","replace","String","unitless","px","sortByBreakpointValue","a","b","parseInt","sortBps","entries","sort","normalize","sorted","assign","Set","subtract","factor","endsWith","m","queryString","min","max","query","push","join","analyzeBreakpoints","base","normalized","queries","entry","breakpoint","minW","maxW","undefined","maxWQuery","minWQuery","minMaxQuery","_keys","_keysArr","Array","from","isResponsive","test","has","asObject","asArray","details","media","slice","toArrayValue","Error","bp","toObjectValue","isArray","acc","isCustomBreakpoint","maybeBreakpoint","Number","isNaN"],"mappings":"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","sourcesContent":["import { getLastItem } from \"./array\"\nimport { isArray, isNumber, isObject } from \"./assertion\"\nimport { fromEntries, objectKeys } from \"./object\"\nimport { Dict } from \"./types\"\n\nexport const breakpoints = Object.freeze([\n  \"base\",\n  \"sm\",\n  \"md\",\n  \"lg\",\n  \"xl\",\n  \"2xl\",\n])\n\nexport function mapResponsive(prop: any, mapper: (val: any) => any) {\n  if (isArray(prop)) {\n    return prop.map((item) => {\n      if (item === null) {\n        return null\n      }\n      return mapper(item)\n    })\n  }\n\n  if (isObject(prop)) {\n    return objectKeys(prop).reduce((result: Dict, key) => {\n      result[key] = mapper(prop[key])\n      return result\n    }, {})\n  }\n\n  if (prop != null) {\n    return mapper(prop)\n  }\n\n  return null\n}\n\nexport function objectToArrayNotation(obj: Dict, bps = breakpoints) {\n  const result = bps.map((br) => obj[br] ?? null)\n  while (getLastItem(result) === null) {\n    result.pop()\n  }\n  return result\n}\n\nexport function arrayToObjectNotation(values: any[], bps = breakpoints) {\n  const result = {} as Dict\n  values.forEach((value, index) => {\n    const key = bps[index]\n    if (value == null) return\n    result[key] = value\n  })\n  return result\n}\n\nexport function isResponsiveObjectLike(obj: Dict, bps = breakpoints) {\n  const keys = Object.keys(obj)\n  return keys.length > 0 && keys.every((key) => bps.includes(key))\n}\n\n/**\n * @note\n * The code below is the recommended way to analyze breakpoints\n * related stuff. Avoid using functions above, it'll be removed in the\n * next major\n */\n\nconst analyzeCSSValue = (value: number | string) => {\n  const num = parseFloat(value.toString())\n  const unit = value.toString().replace(String(num), \"\")\n  return { unitless: !unit, value: num, unit }\n}\n\nexport const px = (value: number | string): string => {\n  if (value == null) return value\n  const { unitless } = analyzeCSSValue(value)\n  return unitless || isNumber(value) ? `${value}px` : value\n}\n\nconst sortByBreakpointValue = (a: any[], b: any[]) =>\n  parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1\n\nconst sortBps = (breakpoints: Dict): Dict =>\n  fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue))\n\nfunction normalize(breakpoints: Dict) {\n  const sorted = sortBps(breakpoints)\n  return Object.assign(Object.values(sorted), sorted) as string[]\n}\n\nfunction keys(breakpoints: Dict) {\n  const value = Object.keys(sortBps(breakpoints))\n  return new Set(value)\n}\n\nfunction subtract(value: string) {\n  if (!value) return value\n  value = px(value)\n  const factor = value.endsWith(\"px\")\n    ? -1\n    : // the equivalent of 1px in em using a 16px base\n      -0.0635\n  return isNumber(value)\n    ? `${value + factor}`\n    : value.replace(/(\\d+\\.?\\d*)/u, (m) => `${parseFloat(m) + factor}`)\n}\n\nfunction queryString(min: string | null, max?: string) {\n  const query = []\n\n  if (min) query.push(`@media screen and (min-width: ${px(min)})`)\n  if (query.length > 0 && max) query.push(\"and\")\n  if (max) query.push(`@media screen and (max-width: ${px(max)})`)\n\n  return query.join(\" \")\n}\n\nexport function analyzeBreakpoints(breakpoints: Dict) {\n  if (!breakpoints) return null\n\n  breakpoints.base = breakpoints.base ?? \"0px\"\n\n  const normalized = normalize(breakpoints)\n\n  const queries = Object.entries(breakpoints)\n    .sort(sortByBreakpointValue)\n    .map(([breakpoint, minW], index, entry) => {\n      let [, maxW] = entry[index + 1] ?? []\n      maxW = parseFloat(maxW) > 0 ? subtract(maxW) : undefined\n      return {\n        breakpoint,\n        minW,\n        maxW,\n        maxWQuery: queryString(null, maxW),\n        minWQuery: queryString(minW),\n        minMaxQuery: queryString(minW, maxW),\n      }\n    })\n\n  const _keys = keys(breakpoints)\n  const _keysArr = Array.from(_keys.values())\n\n  return {\n    keys: _keys,\n    normalized,\n    isResponsive(test: Dict) {\n      const keys = Object.keys(test)\n      return keys.length > 0 && keys.every((key) => _keys.has(key))\n    },\n    asObject: sortBps(breakpoints),\n    asArray: normalize(breakpoints),\n    details: queries,\n    media: [null, ...normalized.map((minW) => queryString(minW)).slice(1)],\n    toArrayValue(test: Dict) {\n      if (!isObject(test)) {\n        throw new Error(\"toArrayValue: value must be an object\")\n      }\n      const result = _keysArr.map((bp) => test[bp] ?? null)\n      while (getLastItem(result) === null) result.pop()\n      return result\n    },\n    toObjectValue(test: any[]) {\n      if (!Array.isArray(test)) {\n        throw new Error(\"toObjectValue: value must be an array\")\n      }\n      return test.reduce((acc, value, index) => {\n        const key = _keysArr[index]\n        if (key != null && value != null) acc[key] = value\n        return acc\n      }, {} as Dict)\n    },\n  }\n}\n\nexport type AnalyzeBreakpointsReturn = ReturnType<typeof analyzeBreakpoints>\n\n/**\n * since breakpoints are defined as custom properties on an array, you may\n * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices\n * and custom breakpoints as string.\n *\n * This function returns true given a custom array property.\n */\nexport const isCustomBreakpoint = (maybeBreakpoint: string) =>\n  Number.isNaN(Number(maybeBreakpoint))\n"],"file":"responsive.js"}